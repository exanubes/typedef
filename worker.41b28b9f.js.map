{"mappings":"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","sources":["<anon>","src/js/rpc/worker.js","src/js/rpc/wasm_exec.js","node_modules/.pnpm/@parcel+runtime-js@2.16.3_@parcel+core@2.16.3_@swc+helpers@0.5.17_/node_modules/@parcel/runtime-js/lib/runtime-56c787ee6452ac25.js"],"sourcesContent":["\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$resolve(url) {\n  url = parcelRequire.i?.[url] || url;\n  return import.meta.resolve($parcel$distDir + url);\n}\n\n      var $parcel$global = globalThis;\n    var $parcel$distDir = \"./\";\n\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire0939\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire0939\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"5eXpU\", function(module, exports) {\nparcelRequire(\"ctyHd\");\n\nvar $7Dwz3 = parcelRequire(\"7Dwz3\");\n// NOTE: Go ctor is attached to global context by wasm_exec.js\nconst $3d0c597f7f11ef48$var$go = new Go();\nlet $3d0c597f7f11ef48$var$ready = false;\nlet $3d0c597f7f11ef48$var$wasm_ready_resolve;\nconst $3d0c597f7f11ef48$var$wasmReady = new Promise((resolve)=>$3d0c597f7f11ef48$var$wasm_ready_resolve = resolve);\n(async ()=>{\n    const response = await fetch((0, (/*@__PURE__*/$parcel$interopDefault($7Dwz3))));\n    const bytes = await response.arrayBuffer();\n    const { instance: instance } = await WebAssembly.instantiate(bytes, $3d0c597f7f11ef48$var$go.importObject);\n    $3d0c597f7f11ef48$var$go.run(instance);\n    $3d0c597f7f11ef48$var$wasm_ready_resolve();\n})();\n/**\n *\n * @param event\n */ self.onmessage = async (event)=>{\n    await $3d0c597f7f11ef48$var$wasmReady;\n    self.rpc(JSON.stringify(event.data));\n};\n\n});\nparcelRegister(\"ctyHd\", function(module, exports) {\n// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n'use strict';\n(()=>{\n    /**\n     *\n     */ const enosys = ()=>{\n        const err = new Error('not implemented');\n        err.code = 'ENOSYS';\n        return err;\n    };\n    if (!globalThis.fs) {\n        let outputBuf = '';\n        globalThis.fs = {\n            constants: {\n                O_WRONLY: -1,\n                O_RDWR: -1,\n                O_CREAT: -1,\n                O_TRUNC: -1,\n                O_APPEND: -1,\n                O_EXCL: -1,\n                O_DIRECTORY: -1\n            },\n            /**\n             *\n             * @param fd\n             * @param buf\n             */ writeSync (fd, buf) {\n                outputBuf += decoder.decode(buf);\n                const nl = outputBuf.lastIndexOf('\\n');\n                if (nl != -1) {\n                    console.log(outputBuf.substring(0, nl));\n                    outputBuf = outputBuf.substring(nl + 1);\n                }\n                return buf.length;\n            },\n            /**\n             *\n             * @param fd\n             * @param buf\n             * @param offset\n             * @param length\n             * @param position\n             * @param callback\n             */ write (fd, buf, offset, length, position, callback) {\n                if (offset !== 0 || length !== buf.length || position !== null) {\n                    callback(enosys());\n                    return;\n                }\n                const n = this.writeSync(fd, buf);\n                callback(null, n);\n            },\n            /**\n             *\n             * @param path\n             * @param mode\n             * @param callback\n             */ chmod (path, mode, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param uid\n             * @param gid\n             * @param callback\n             */ chown (path, uid, gid, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param fd\n             * @param callback\n             */ close (fd, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param fd\n             * @param mode\n             * @param callback\n             */ fchmod (fd, mode, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param fd\n             * @param uid\n             * @param gid\n             * @param callback\n             */ fchown (fd, uid, gid, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param fd\n             * @param callback\n             */ fstat (fd, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param fd\n             * @param callback\n             */ fsync (fd, callback) {\n                callback(null);\n            },\n            /**\n             *\n             * @param fd\n             * @param length\n             * @param callback\n             */ ftruncate (fd, length, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param uid\n             * @param gid\n             * @param callback\n             */ lchown (path, uid, gid, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param link\n             * @param callback\n             */ link (path, link, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param callback\n             */ lstat (path, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param perm\n             * @param callback\n             */ mkdir (path, perm, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param flags\n             * @param mode\n             * @param callback\n             */ open (path, flags, mode, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param fd\n             * @param buffer\n             * @param offset\n             * @param length\n             * @param position\n             * @param callback\n             */ read (fd, buffer, offset, length, position, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param callback\n             */ readdir (path, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param callback\n             */ readlink (path, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param from\n             * @param to\n             * @param callback\n             */ rename (from, to, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param callback\n             */ rmdir (path, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param callback\n             */ stat (path, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param link\n             * @param callback\n             */ symlink (path, link, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param length\n             * @param callback\n             */ truncate (path, length, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param callback\n             */ unlink (path, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param atime\n             * @param mtime\n             * @param callback\n             */ utimes (path, atime, mtime, callback) {\n                callback(enosys());\n            }\n        };\n    }\n    if (!globalThis.process) globalThis.process = {\n        /**\n             *\n             */ getuid () {\n            return -1;\n        },\n        /**\n             *\n             */ getgid () {\n            return -1;\n        },\n        /**\n             *\n             */ geteuid () {\n            return -1;\n        },\n        /**\n             *\n             */ getegid () {\n            return -1;\n        },\n        /**\n             *\n             */ getgroups () {\n            throw enosys();\n        },\n        pid: -1,\n        ppid: -1,\n        /**\n             *\n             */ umask () {\n            throw enosys();\n        },\n        /**\n             *\n             */ cwd () {\n            throw enosys();\n        },\n        /**\n             *\n             */ chdir () {\n            throw enosys();\n        }\n    };\n    if (!globalThis.path) globalThis.path = {\n        /**\n             *\n             * @param {...any} pathSegments\n             */ resolve (...pathSegments) {\n            return pathSegments.join('/');\n        }\n    };\n    if (!globalThis.crypto) throw new Error('globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)');\n    if (!globalThis.performance) throw new Error('globalThis.performance is not available, polyfill required (performance.now only)');\n    if (!globalThis.TextEncoder) throw new Error('globalThis.TextEncoder is not available, polyfill required');\n    if (!globalThis.TextDecoder) throw new Error('globalThis.TextDecoder is not available, polyfill required');\n    const encoder = new TextEncoder('utf-8');\n    const decoder = new TextDecoder('utf-8');\n    /**\n     *\n     */ globalThis.Go = class {\n        /**\n         *\n         */ constructor(){\n            this.argv = [\n                'js'\n            ];\n            this.env = {};\n            /**\n             *\n             * @param code\n             */ this.exit = (code)=>{\n                if (code !== 0) console.warn('exit code:', code);\n            };\n            this._exitPromise = new Promise((resolve)=>{\n                this._resolveExitPromise = resolve;\n            });\n            this._pendingEvent = null;\n            this._scheduledTimeouts = new Map();\n            this._nextCallbackTimeoutID = 1;\n            /**\n             *\n             * @param addr\n             * @param v\n             */ const setInt64 = (addr, v)=>{\n                this.mem.setUint32(addr + 0, v, true);\n                this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n            };\n            /**\n             *\n             * @param addr\n             * @param v\n             */ const setInt32 = (addr, v)=>{\n                this.mem.setUint32(addr + 0, v, true);\n            };\n            /**\n             *\n             * @param addr\n             */ const getInt64 = (addr)=>{\n                const low = this.mem.getUint32(addr + 0, true);\n                const high = this.mem.getInt32(addr + 4, true);\n                return low + high * 4294967296;\n            };\n            /**\n             *\n             * @param addr\n             */ const loadValue = (addr)=>{\n                const f = this.mem.getFloat64(addr, true);\n                if (f === 0) return undefined;\n                if (!isNaN(f)) return f;\n                const id = this.mem.getUint32(addr, true);\n                return this._values[id];\n            };\n            /**\n             *\n             * @param addr\n             * @param v\n             */ const storeValue = (addr, v)=>{\n                const nanHead = 0x7ff80000;\n                if (typeof v === 'number' && v !== 0) {\n                    if (isNaN(v)) {\n                        this.mem.setUint32(addr + 4, nanHead, true);\n                        this.mem.setUint32(addr, 0, true);\n                        return;\n                    }\n                    this.mem.setFloat64(addr, v, true);\n                    return;\n                }\n                if (v === undefined) {\n                    this.mem.setFloat64(addr, 0, true);\n                    return;\n                }\n                let id = this._ids.get(v);\n                if (id === undefined) {\n                    id = this._idPool.pop();\n                    if (id === undefined) id = this._values.length;\n                    this._values[id] = v;\n                    this._goRefCounts[id] = 0;\n                    this._ids.set(v, id);\n                }\n                this._goRefCounts[id]++;\n                let typeFlag = 0;\n                switch(typeof v){\n                    case 'object':\n                        if (v !== null) typeFlag = 1;\n                        break;\n                    case 'string':\n                        typeFlag = 2;\n                        break;\n                    case 'symbol':\n                        typeFlag = 3;\n                        break;\n                    case 'function':\n                        typeFlag = 4;\n                        break;\n                }\n                this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n                this.mem.setUint32(addr, id, true);\n            };\n            /**\n             *\n             * @param addr\n             */ const loadSlice = (addr)=>{\n                const array = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n            };\n            /**\n             *\n             * @param addr\n             */ const loadSliceOfValues = (addr)=>{\n                const array = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                const a = new Array(len);\n                for(let i = 0; i < len; i++)a[i] = loadValue(array + i * 8);\n                return a;\n            };\n            /**\n             *\n             * @param addr\n             */ const loadString = (addr)=>{\n                const saddr = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n            };\n            /**\n             *\n             * @param a\n             * @param b\n             */ const testCallExport = (a, b)=>{\n                this._inst.exports.testExport0();\n                return this._inst.exports.testExport(a, b);\n            };\n            const timeOrigin = Date.now() - performance.now();\n            this.importObject = {\n                _gotest: {\n                    /**\n                     *\n                     * @param a\n                     * @param b\n                     */ add: (a, b)=>a + b,\n                    callExport: testCallExport\n                },\n                gojs: {\n                    // Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n                    // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n                    // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n                    // This changes the SP, thus we have to update the SP used by the imported function.\n                    // func wasmExit(code int32)\n                    /**\n                     *\n                     * @param sp\n                     */ 'runtime.wasmExit': (sp)=>{\n                        sp >>>= 0;\n                        const code = this.mem.getInt32(sp + 8, true);\n                        this.exited = true;\n                        delete this._inst;\n                        delete this._values;\n                        delete this._goRefCounts;\n                        delete this._ids;\n                        delete this._idPool;\n                        this.exit(code);\n                    },\n                    // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n                    /**\n                     *\n                     * @param sp\n                     */ 'runtime.wasmWrite': (sp)=>{\n                        sp >>>= 0;\n                        const fd = getInt64(sp + 8);\n                        const p = getInt64(sp + 16);\n                        const n = this.mem.getInt32(sp + 24, true);\n                        fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n                    },\n                    // func resetMemoryDataView()\n                    /**\n                     *\n                     * @param sp\n                     */ 'runtime.resetMemoryDataView': (sp)=>{\n                        sp >>>= 0;\n                        this.mem = new DataView(this._inst.exports.mem.buffer);\n                    },\n                    // func nanotime1() int64\n                    /**\n                     *\n                     * @param sp\n                     */ 'runtime.nanotime1': (sp)=>{\n                        sp >>>= 0;\n                        setInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);\n                    },\n                    // func walltime() (sec int64, nsec int32)\n                    /**\n                     *\n                     * @param sp\n                     */ 'runtime.walltime': (sp)=>{\n                        sp >>>= 0;\n                        const msec = new Date().getTime();\n                        setInt64(sp + 8, msec / 1000);\n                        this.mem.setInt32(sp + 16, msec % 1000 * 1000000, true);\n                    },\n                    // func scheduleTimeoutEvent(delay int64) int32\n                    /**\n                     *\n                     * @param sp\n                     */ 'runtime.scheduleTimeoutEvent': (sp)=>{\n                        sp >>>= 0;\n                        const id = this._nextCallbackTimeoutID;\n                        this._nextCallbackTimeoutID++;\n                        this._scheduledTimeouts.set(id, setTimeout(()=>{\n                            this._resume();\n                            while(this._scheduledTimeouts.has(id)){\n                                // for some reason Go failed to register the timeout event, log and try again\n                                // (temporary workaround for https://github.com/golang/go/issues/28975)\n                                console.warn('scheduleTimeoutEvent: missed timeout event');\n                                this._resume();\n                            }\n                        }, getInt64(sp + 8)));\n                        this.mem.setInt32(sp + 16, id, true);\n                    },\n                    // func clearTimeoutEvent(id int32)\n                    /**\n                     *\n                     * @param sp\n                     */ 'runtime.clearTimeoutEvent': (sp)=>{\n                        sp >>>= 0;\n                        const id = this.mem.getInt32(sp + 8, true);\n                        clearTimeout(this._scheduledTimeouts.get(id));\n                        this._scheduledTimeouts.delete(id);\n                    },\n                    // func getRandomData(r []byte)\n                    /**\n                     *\n                     * @param sp\n                     */ 'runtime.getRandomData': (sp)=>{\n                        sp >>>= 0;\n                        crypto.getRandomValues(loadSlice(sp + 8));\n                    },\n                    // func finalizeRef(v ref)\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.finalizeRef': (sp)=>{\n                        sp >>>= 0;\n                        const id = this.mem.getUint32(sp + 8, true);\n                        this._goRefCounts[id]--;\n                        if (this._goRefCounts[id] === 0) {\n                            const v = this._values[id];\n                            this._values[id] = null;\n                            this._ids.delete(v);\n                            this._idPool.push(id);\n                        }\n                    },\n                    // func stringVal(value string) ref\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.stringVal': (sp)=>{\n                        sp >>>= 0;\n                        storeValue(sp + 24, loadString(sp + 8));\n                    },\n                    // func valueGet(v ref, p string) ref\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.valueGet': (sp)=>{\n                        sp >>>= 0;\n                        const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                        sp = this._inst.exports.getsp() >>> 0; // see comment above\n                        storeValue(sp + 32, result);\n                    },\n                    // func valueSet(v ref, p string, x ref)\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.valueSet': (sp)=>{\n                        sp >>>= 0;\n                        Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                    },\n                    // func valueDelete(v ref, p string)\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.valueDelete': (sp)=>{\n                        sp >>>= 0;\n                        Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                    },\n                    // func valueIndex(v ref, i int) ref\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.valueIndex': (sp)=>{\n                        sp >>>= 0;\n                        storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                    },\n                    // valueSetIndex(v ref, i int, x ref)\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.valueSetIndex': (sp)=>{\n                        sp >>>= 0;\n                        Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                    },\n                    // func valueCall(v ref, m string, args []ref) (ref, bool)\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.valueCall': (sp)=>{\n                        sp >>>= 0;\n                        try {\n                            const v = loadValue(sp + 8);\n                            const m = Reflect.get(v, loadString(sp + 16));\n                            const args = loadSliceOfValues(sp + 32);\n                            const result = Reflect.apply(m, v, args);\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 56, result);\n                            this.mem.setUint8(sp + 64, 1);\n                        } catch (err) {\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 56, err);\n                            this.mem.setUint8(sp + 64, 0);\n                        }\n                    },\n                    // func valueInvoke(v ref, args []ref) (ref, bool)\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.valueInvoke': (sp)=>{\n                        sp >>>= 0;\n                        try {\n                            const v = loadValue(sp + 8);\n                            const args = loadSliceOfValues(sp + 16);\n                            const result = Reflect.apply(v, undefined, args);\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 40, result);\n                            this.mem.setUint8(sp + 48, 1);\n                        } catch (err) {\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 40, err);\n                            this.mem.setUint8(sp + 48, 0);\n                        }\n                    },\n                    // func valueNew(v ref, args []ref) (ref, bool)\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.valueNew': (sp)=>{\n                        sp >>>= 0;\n                        try {\n                            const v = loadValue(sp + 8);\n                            const args = loadSliceOfValues(sp + 16);\n                            const result = Reflect.construct(v, args);\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 40, result);\n                            this.mem.setUint8(sp + 48, 1);\n                        } catch (err) {\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 40, err);\n                            this.mem.setUint8(sp + 48, 0);\n                        }\n                    },\n                    // func valueLength(v ref) int\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.valueLength': (sp)=>{\n                        sp >>>= 0;\n                        setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                    },\n                    // valuePrepareString(v ref) (ref, int)\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.valuePrepareString': (sp)=>{\n                        sp >>>= 0;\n                        const str = encoder.encode(String(loadValue(sp + 8)));\n                        storeValue(sp + 16, str);\n                        setInt64(sp + 24, str.length);\n                    },\n                    // valueLoadString(v ref, b []byte)\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.valueLoadString': (sp)=>{\n                        sp >>>= 0;\n                        const str = loadValue(sp + 8);\n                        loadSlice(sp + 16).set(str);\n                    },\n                    // func valueInstanceOf(v ref, t ref) bool\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.valueInstanceOf': (sp)=>{\n                        sp >>>= 0;\n                        this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\n                    },\n                    // func copyBytesToGo(dst []byte, src ref) (int, bool)\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.copyBytesToGo': (sp)=>{\n                        sp >>>= 0;\n                        const dst = loadSlice(sp + 8);\n                        const src = loadValue(sp + 32);\n                        if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                            this.mem.setUint8(sp + 48, 0);\n                            return;\n                        }\n                        const toCopy = src.subarray(0, dst.length);\n                        dst.set(toCopy);\n                        setInt64(sp + 40, toCopy.length);\n                        this.mem.setUint8(sp + 48, 1);\n                    },\n                    // func copyBytesToJS(dst ref, src []byte) (int, bool)\n                    /**\n                     *\n                     * @param sp\n                     */ 'syscall/js.copyBytesToJS': (sp)=>{\n                        sp >>>= 0;\n                        const dst = loadValue(sp + 8);\n                        const src = loadSlice(sp + 16);\n                        if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                            this.mem.setUint8(sp + 48, 0);\n                            return;\n                        }\n                        const toCopy = src.subarray(0, dst.length);\n                        dst.set(toCopy);\n                        setInt64(sp + 40, toCopy.length);\n                        this.mem.setUint8(sp + 48, 1);\n                    },\n                    /**\n                     *\n                     * @param value\n                     */ debug: (value)=>{\n                        console.log(value);\n                    }\n                }\n            };\n        }\n        /**\n         *\n         * @param instance\n         */ async run(instance) {\n            if (!(instance instanceof WebAssembly.Instance)) throw new Error('Go.run: WebAssembly.Instance expected');\n            this._inst = instance;\n            this.mem = new DataView(this._inst.exports.mem.buffer);\n            this._values = [\n                // JS values that Go currently has references to, indexed by reference id\n                NaN,\n                0,\n                null,\n                true,\n                false,\n                globalThis,\n                this\n            ];\n            this._goRefCounts = new Array(this._values.length).fill(Infinity); // number of references that Go has to a JS value, indexed by reference id\n            this._ids = new Map([\n                // mapping from JS values to reference ids\n                [\n                    0,\n                    1\n                ],\n                [\n                    null,\n                    2\n                ],\n                [\n                    true,\n                    3\n                ],\n                [\n                    false,\n                    4\n                ],\n                [\n                    globalThis,\n                    5\n                ],\n                [\n                    this,\n                    6\n                ]\n            ]);\n            this._idPool = []; // unused ids that have been garbage collected\n            this.exited = false; // whether the Go program has exited\n            // Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n            let offset = 4096;\n            /**\n             *\n             * @param str\n             */ const strPtr = (str)=>{\n                const ptr = offset;\n                const bytes = encoder.encode(str + '\\0');\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n                offset += bytes.length;\n                if (offset % 8 !== 0) offset += 8 - offset % 8;\n                return ptr;\n            };\n            const argc = this.argv.length;\n            const argvPtrs = [];\n            this.argv.forEach((arg)=>{\n                argvPtrs.push(strPtr(arg));\n            });\n            argvPtrs.push(0);\n            const keys = Object.keys(this.env).sort();\n            keys.forEach((key)=>{\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n            });\n            argvPtrs.push(0);\n            const argv = offset;\n            argvPtrs.forEach((ptr)=>{\n                this.mem.setUint32(offset, ptr, true);\n                this.mem.setUint32(offset + 4, 0, true);\n                offset += 8;\n            });\n            // The linker guarantees global data starts from at least wasmMinDataAddr.\n            // Keep in sync with cmd/link/internal/ld/data.go:wasmMinDataAddr.\n            const wasmMinDataAddr = 12288;\n            if (offset >= wasmMinDataAddr) throw new Error('total length of command line and environment variables exceeds limit');\n            this._inst.exports.run(argc, argv);\n            if (this.exited) this._resolveExitPromise();\n            await this._exitPromise;\n        }\n        /**\n         *\n         */ _resume() {\n            if (this.exited) throw new Error('Go program has already exited');\n            this._inst.exports.resume();\n            if (this.exited) this._resolveExitPromise();\n        }\n        /**\n         *\n         * @param id\n         */ _makeFuncWrapper(id) {\n            const go = this;\n            return function() {\n                const event = {\n                    id: id,\n                    this: this,\n                    args: arguments\n                };\n                go._pendingEvent = event;\n                go._resume();\n                return event.result;\n            };\n        }\n    };\n})();\n\n});\n\nparcelRegister(\"7Dwz3\", function(module, exports) {\nmodule.exports = $parcel$resolve(\"main.aeb173d5.wasm\");\n\n});\n\n\n\nparcelRequire(\"5eXpU\");\n\n//# sourceMappingURL=worker.41b28b9f.js.map\n","import './wasm_exec.js';\nimport wasm_url from 'url:./main.wasm';\n\n// NOTE: Go ctor is attached to global context by wasm_exec.js\nconst go = new Go();\n\nlet ready = false;\n\nlet wasm_ready_resolve;\n\nconst wasmReady = new Promise((resolve) => (wasm_ready_resolve = resolve));\n(async () => {\n    const response = await fetch(wasm_url);\n    const bytes = await response.arrayBuffer();\n\n    const { instance } = await WebAssembly.instantiate(bytes, go.importObject);\n    go.run(instance);\n    wasm_ready_resolve();\n})();\n\n/**\n *\n * @param event\n */\nself.onmessage = async (event) => {\n    await wasmReady;\n    self.rpc(JSON.stringify(event.data));\n};\n","// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n'use strict';\n\n(() => {\n    /**\n     *\n     */\n    const enosys = () => {\n        const err = new Error('not implemented');\n        err.code = 'ENOSYS';\n        return err;\n    };\n\n    if (!globalThis.fs) {\n        let outputBuf = '';\n        globalThis.fs = {\n            constants: {\n                O_WRONLY: -1,\n                O_RDWR: -1,\n                O_CREAT: -1,\n                O_TRUNC: -1,\n                O_APPEND: -1,\n                O_EXCL: -1,\n                O_DIRECTORY: -1,\n            }, // unused\n            /**\n             *\n             * @param fd\n             * @param buf\n             */\n            writeSync(fd, buf) {\n                outputBuf += decoder.decode(buf);\n                const nl = outputBuf.lastIndexOf('\\n');\n                if (nl != -1) {\n                    console.log(outputBuf.substring(0, nl));\n                    outputBuf = outputBuf.substring(nl + 1);\n                }\n                return buf.length;\n            },\n            /**\n             *\n             * @param fd\n             * @param buf\n             * @param offset\n             * @param length\n             * @param position\n             * @param callback\n             */\n            write(fd, buf, offset, length, position, callback) {\n                if (offset !== 0 || length !== buf.length || position !== null) {\n                    callback(enosys());\n                    return;\n                }\n                const n = this.writeSync(fd, buf);\n                callback(null, n);\n            },\n            /**\n             *\n             * @param path\n             * @param mode\n             * @param callback\n             */\n            chmod(path, mode, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param uid\n             * @param gid\n             * @param callback\n             */\n            chown(path, uid, gid, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param fd\n             * @param callback\n             */\n            close(fd, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param fd\n             * @param mode\n             * @param callback\n             */\n            fchmod(fd, mode, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param fd\n             * @param uid\n             * @param gid\n             * @param callback\n             */\n            fchown(fd, uid, gid, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param fd\n             * @param callback\n             */\n            fstat(fd, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param fd\n             * @param callback\n             */\n            fsync(fd, callback) {\n                callback(null);\n            },\n            /**\n             *\n             * @param fd\n             * @param length\n             * @param callback\n             */\n            ftruncate(fd, length, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param uid\n             * @param gid\n             * @param callback\n             */\n            lchown(path, uid, gid, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param link\n             * @param callback\n             */\n            link(path, link, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param callback\n             */\n            lstat(path, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param perm\n             * @param callback\n             */\n            mkdir(path, perm, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param flags\n             * @param mode\n             * @param callback\n             */\n            open(path, flags, mode, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param fd\n             * @param buffer\n             * @param offset\n             * @param length\n             * @param position\n             * @param callback\n             */\n            read(fd, buffer, offset, length, position, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param callback\n             */\n            readdir(path, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param callback\n             */\n            readlink(path, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param from\n             * @param to\n             * @param callback\n             */\n            rename(from, to, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param callback\n             */\n            rmdir(path, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param callback\n             */\n            stat(path, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param link\n             * @param callback\n             */\n            symlink(path, link, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param length\n             * @param callback\n             */\n            truncate(path, length, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param callback\n             */\n            unlink(path, callback) {\n                callback(enosys());\n            },\n            /**\n             *\n             * @param path\n             * @param atime\n             * @param mtime\n             * @param callback\n             */\n            utimes(path, atime, mtime, callback) {\n                callback(enosys());\n            },\n        };\n    }\n\n    if (!globalThis.process) {\n        globalThis.process = {\n            /**\n             *\n             */\n            getuid() {\n                return -1;\n            },\n            /**\n             *\n             */\n            getgid() {\n                return -1;\n            },\n            /**\n             *\n             */\n            geteuid() {\n                return -1;\n            },\n            /**\n             *\n             */\n            getegid() {\n                return -1;\n            },\n            /**\n             *\n             */\n            getgroups() {\n                throw enosys();\n            },\n            pid: -1,\n            ppid: -1,\n            /**\n             *\n             */\n            umask() {\n                throw enosys();\n            },\n            /**\n             *\n             */\n            cwd() {\n                throw enosys();\n            },\n            /**\n             *\n             */\n            chdir() {\n                throw enosys();\n            },\n        };\n    }\n\n    if (!globalThis.path) {\n        globalThis.path = {\n            /**\n             *\n             * @param {...any} pathSegments\n             */\n            resolve(...pathSegments) {\n                return pathSegments.join('/');\n            },\n        };\n    }\n\n    if (!globalThis.crypto) {\n        throw new Error(\n            'globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)'\n        );\n    }\n\n    if (!globalThis.performance) {\n        throw new Error(\n            'globalThis.performance is not available, polyfill required (performance.now only)'\n        );\n    }\n\n    if (!globalThis.TextEncoder) {\n        throw new Error('globalThis.TextEncoder is not available, polyfill required');\n    }\n\n    if (!globalThis.TextDecoder) {\n        throw new Error('globalThis.TextDecoder is not available, polyfill required');\n    }\n\n    const encoder = new TextEncoder('utf-8');\n    const decoder = new TextDecoder('utf-8');\n\n    /**\n     *\n     */\n    globalThis.Go = class {\n        /**\n         *\n         */\n        constructor() {\n            this.argv = ['js'];\n            this.env = {};\n            /**\n             *\n             * @param code\n             */\n            this.exit = (code) => {\n                if (code !== 0) {\n                    console.warn('exit code:', code);\n                }\n            };\n            this._exitPromise = new Promise((resolve) => {\n                this._resolveExitPromise = resolve;\n            });\n            this._pendingEvent = null;\n            this._scheduledTimeouts = new Map();\n            this._nextCallbackTimeoutID = 1;\n\n            /**\n             *\n             * @param addr\n             * @param v\n             */\n            const setInt64 = (addr, v) => {\n                this.mem.setUint32(addr + 0, v, true);\n                this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n            };\n\n            /**\n             *\n             * @param addr\n             * @param v\n             */\n            const setInt32 = (addr, v) => {\n                this.mem.setUint32(addr + 0, v, true);\n            };\n\n            /**\n             *\n             * @param addr\n             */\n            const getInt64 = (addr) => {\n                const low = this.mem.getUint32(addr + 0, true);\n                const high = this.mem.getInt32(addr + 4, true);\n                return low + high * 4294967296;\n            };\n\n            /**\n             *\n             * @param addr\n             */\n            const loadValue = (addr) => {\n                const f = this.mem.getFloat64(addr, true);\n                if (f === 0) {\n                    return undefined;\n                }\n                if (!isNaN(f)) {\n                    return f;\n                }\n\n                const id = this.mem.getUint32(addr, true);\n                return this._values[id];\n            };\n\n            /**\n             *\n             * @param addr\n             * @param v\n             */\n            const storeValue = (addr, v) => {\n                const nanHead = 0x7ff80000;\n\n                if (typeof v === 'number' && v !== 0) {\n                    if (isNaN(v)) {\n                        this.mem.setUint32(addr + 4, nanHead, true);\n                        this.mem.setUint32(addr, 0, true);\n                        return;\n                    }\n                    this.mem.setFloat64(addr, v, true);\n                    return;\n                }\n\n                if (v === undefined) {\n                    this.mem.setFloat64(addr, 0, true);\n                    return;\n                }\n\n                let id = this._ids.get(v);\n                if (id === undefined) {\n                    id = this._idPool.pop();\n                    if (id === undefined) {\n                        id = this._values.length;\n                    }\n                    this._values[id] = v;\n                    this._goRefCounts[id] = 0;\n                    this._ids.set(v, id);\n                }\n                this._goRefCounts[id]++;\n                let typeFlag = 0;\n                switch (typeof v) {\n                    case 'object':\n                        if (v !== null) {\n                            typeFlag = 1;\n                        }\n                        break;\n                    case 'string':\n                        typeFlag = 2;\n                        break;\n                    case 'symbol':\n                        typeFlag = 3;\n                        break;\n                    case 'function':\n                        typeFlag = 4;\n                        break;\n                }\n                this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n                this.mem.setUint32(addr, id, true);\n            };\n\n            /**\n             *\n             * @param addr\n             */\n            const loadSlice = (addr) => {\n                const array = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n            };\n\n            /**\n             *\n             * @param addr\n             */\n            const loadSliceOfValues = (addr) => {\n                const array = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                const a = new Array(len);\n                for (let i = 0; i < len; i++) {\n                    a[i] = loadValue(array + i * 8);\n                }\n                return a;\n            };\n\n            /**\n             *\n             * @param addr\n             */\n            const loadString = (addr) => {\n                const saddr = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n            };\n\n            /**\n             *\n             * @param a\n             * @param b\n             */\n            const testCallExport = (a, b) => {\n                this._inst.exports.testExport0();\n                return this._inst.exports.testExport(a, b);\n            };\n\n            const timeOrigin = Date.now() - performance.now();\n            this.importObject = {\n                _gotest: {\n                    /**\n                     *\n                     * @param a\n                     * @param b\n                     */\n                    add: (a, b) => a + b,\n                    callExport: testCallExport,\n                },\n                gojs: {\n                    // Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n                    // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n                    // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n                    // This changes the SP, thus we have to update the SP used by the imported function.\n\n                    // func wasmExit(code int32)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'runtime.wasmExit': (sp) => {\n                        sp >>>= 0;\n                        const code = this.mem.getInt32(sp + 8, true);\n                        this.exited = true;\n                        delete this._inst;\n                        delete this._values;\n                        delete this._goRefCounts;\n                        delete this._ids;\n                        delete this._idPool;\n                        this.exit(code);\n                    },\n\n                    // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'runtime.wasmWrite': (sp) => {\n                        sp >>>= 0;\n                        const fd = getInt64(sp + 8);\n                        const p = getInt64(sp + 16);\n                        const n = this.mem.getInt32(sp + 24, true);\n                        fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n                    },\n\n                    // func resetMemoryDataView()\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'runtime.resetMemoryDataView': (sp) => {\n                        sp >>>= 0;\n                        this.mem = new DataView(this._inst.exports.mem.buffer);\n                    },\n\n                    // func nanotime1() int64\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'runtime.nanotime1': (sp) => {\n                        sp >>>= 0;\n                        setInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);\n                    },\n\n                    // func walltime() (sec int64, nsec int32)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'runtime.walltime': (sp) => {\n                        sp >>>= 0;\n                        const msec = new Date().getTime();\n                        setInt64(sp + 8, msec / 1000);\n                        this.mem.setInt32(sp + 16, (msec % 1000) * 1000000, true);\n                    },\n\n                    // func scheduleTimeoutEvent(delay int64) int32\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'runtime.scheduleTimeoutEvent': (sp) => {\n                        sp >>>= 0;\n                        const id = this._nextCallbackTimeoutID;\n                        this._nextCallbackTimeoutID++;\n                        this._scheduledTimeouts.set(\n                            id,\n                            setTimeout(\n                                () => {\n                                    this._resume();\n                                    while (this._scheduledTimeouts.has(id)) {\n                                        // for some reason Go failed to register the timeout event, log and try again\n                                        // (temporary workaround for https://github.com/golang/go/issues/28975)\n                                        console.warn('scheduleTimeoutEvent: missed timeout event');\n                                        this._resume();\n                                    }\n                                },\n                                getInt64(sp + 8)\n                            )\n                        );\n                        this.mem.setInt32(sp + 16, id, true);\n                    },\n\n                    // func clearTimeoutEvent(id int32)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'runtime.clearTimeoutEvent': (sp) => {\n                        sp >>>= 0;\n                        const id = this.mem.getInt32(sp + 8, true);\n                        clearTimeout(this._scheduledTimeouts.get(id));\n                        this._scheduledTimeouts.delete(id);\n                    },\n\n                    // func getRandomData(r []byte)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'runtime.getRandomData': (sp) => {\n                        sp >>>= 0;\n                        crypto.getRandomValues(loadSlice(sp + 8));\n                    },\n\n                    // func finalizeRef(v ref)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.finalizeRef': (sp) => {\n                        sp >>>= 0;\n                        const id = this.mem.getUint32(sp + 8, true);\n                        this._goRefCounts[id]--;\n                        if (this._goRefCounts[id] === 0) {\n                            const v = this._values[id];\n                            this._values[id] = null;\n                            this._ids.delete(v);\n                            this._idPool.push(id);\n                        }\n                    },\n\n                    // func stringVal(value string) ref\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.stringVal': (sp) => {\n                        sp >>>= 0;\n                        storeValue(sp + 24, loadString(sp + 8));\n                    },\n\n                    // func valueGet(v ref, p string) ref\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.valueGet': (sp) => {\n                        sp >>>= 0;\n                        const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                        sp = this._inst.exports.getsp() >>> 0; // see comment above\n                        storeValue(sp + 32, result);\n                    },\n\n                    // func valueSet(v ref, p string, x ref)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.valueSet': (sp) => {\n                        sp >>>= 0;\n                        Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                    },\n\n                    // func valueDelete(v ref, p string)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.valueDelete': (sp) => {\n                        sp >>>= 0;\n                        Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                    },\n\n                    // func valueIndex(v ref, i int) ref\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.valueIndex': (sp) => {\n                        sp >>>= 0;\n                        storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                    },\n\n                    // valueSetIndex(v ref, i int, x ref)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.valueSetIndex': (sp) => {\n                        sp >>>= 0;\n                        Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                    },\n\n                    // func valueCall(v ref, m string, args []ref) (ref, bool)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.valueCall': (sp) => {\n                        sp >>>= 0;\n                        try {\n                            const v = loadValue(sp + 8);\n                            const m = Reflect.get(v, loadString(sp + 16));\n                            const args = loadSliceOfValues(sp + 32);\n                            const result = Reflect.apply(m, v, args);\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 56, result);\n                            this.mem.setUint8(sp + 64, 1);\n                        } catch (err) {\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 56, err);\n                            this.mem.setUint8(sp + 64, 0);\n                        }\n                    },\n\n                    // func valueInvoke(v ref, args []ref) (ref, bool)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.valueInvoke': (sp) => {\n                        sp >>>= 0;\n                        try {\n                            const v = loadValue(sp + 8);\n                            const args = loadSliceOfValues(sp + 16);\n                            const result = Reflect.apply(v, undefined, args);\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 40, result);\n                            this.mem.setUint8(sp + 48, 1);\n                        } catch (err) {\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 40, err);\n                            this.mem.setUint8(sp + 48, 0);\n                        }\n                    },\n\n                    // func valueNew(v ref, args []ref) (ref, bool)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.valueNew': (sp) => {\n                        sp >>>= 0;\n                        try {\n                            const v = loadValue(sp + 8);\n                            const args = loadSliceOfValues(sp + 16);\n                            const result = Reflect.construct(v, args);\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 40, result);\n                            this.mem.setUint8(sp + 48, 1);\n                        } catch (err) {\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 40, err);\n                            this.mem.setUint8(sp + 48, 0);\n                        }\n                    },\n\n                    // func valueLength(v ref) int\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.valueLength': (sp) => {\n                        sp >>>= 0;\n                        setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                    },\n\n                    // valuePrepareString(v ref) (ref, int)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.valuePrepareString': (sp) => {\n                        sp >>>= 0;\n                        const str = encoder.encode(String(loadValue(sp + 8)));\n                        storeValue(sp + 16, str);\n                        setInt64(sp + 24, str.length);\n                    },\n\n                    // valueLoadString(v ref, b []byte)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.valueLoadString': (sp) => {\n                        sp >>>= 0;\n                        const str = loadValue(sp + 8);\n                        loadSlice(sp + 16).set(str);\n                    },\n\n                    // func valueInstanceOf(v ref, t ref) bool\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.valueInstanceOf': (sp) => {\n                        sp >>>= 0;\n                        this.mem.setUint8(\n                            sp + 24,\n                            loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0\n                        );\n                    },\n\n                    // func copyBytesToGo(dst []byte, src ref) (int, bool)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.copyBytesToGo': (sp) => {\n                        sp >>>= 0;\n                        const dst = loadSlice(sp + 8);\n                        const src = loadValue(sp + 32);\n                        if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                            this.mem.setUint8(sp + 48, 0);\n                            return;\n                        }\n                        const toCopy = src.subarray(0, dst.length);\n                        dst.set(toCopy);\n                        setInt64(sp + 40, toCopy.length);\n                        this.mem.setUint8(sp + 48, 1);\n                    },\n\n                    // func copyBytesToJS(dst ref, src []byte) (int, bool)\n                    /**\n                     *\n                     * @param sp\n                     */\n                    'syscall/js.copyBytesToJS': (sp) => {\n                        sp >>>= 0;\n                        const dst = loadValue(sp + 8);\n                        const src = loadSlice(sp + 16);\n                        if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                            this.mem.setUint8(sp + 48, 0);\n                            return;\n                        }\n                        const toCopy = src.subarray(0, dst.length);\n                        dst.set(toCopy);\n                        setInt64(sp + 40, toCopy.length);\n                        this.mem.setUint8(sp + 48, 1);\n                    },\n\n                    /**\n                     *\n                     * @param value\n                     */\n                    debug: (value) => {\n                        console.log(value);\n                    },\n                },\n            };\n        }\n\n        /**\n         *\n         * @param instance\n         */\n        async run(instance) {\n            if (!(instance instanceof WebAssembly.Instance)) {\n                throw new Error('Go.run: WebAssembly.Instance expected');\n            }\n            this._inst = instance;\n            this.mem = new DataView(this._inst.exports.mem.buffer);\n            this._values = [\n                // JS values that Go currently has references to, indexed by reference id\n                NaN,\n                0,\n                null,\n                true,\n                false,\n                globalThis,\n                this,\n            ];\n            this._goRefCounts = new Array(this._values.length).fill(Infinity); // number of references that Go has to a JS value, indexed by reference id\n            this._ids = new Map([\n                // mapping from JS values to reference ids\n                [0, 1],\n                [null, 2],\n                [true, 3],\n                [false, 4],\n                [globalThis, 5],\n                [this, 6],\n            ]);\n            this._idPool = []; // unused ids that have been garbage collected\n            this.exited = false; // whether the Go program has exited\n\n            // Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n            let offset = 4096;\n\n            /**\n             *\n             * @param str\n             */\n            const strPtr = (str) => {\n                const ptr = offset;\n                const bytes = encoder.encode(str + '\\0');\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n                offset += bytes.length;\n                if (offset % 8 !== 0) {\n                    offset += 8 - (offset % 8);\n                }\n                return ptr;\n            };\n\n            const argc = this.argv.length;\n\n            const argvPtrs = [];\n            this.argv.forEach((arg) => {\n                argvPtrs.push(strPtr(arg));\n            });\n            argvPtrs.push(0);\n\n            const keys = Object.keys(this.env).sort();\n            keys.forEach((key) => {\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n            });\n            argvPtrs.push(0);\n\n            const argv = offset;\n            argvPtrs.forEach((ptr) => {\n                this.mem.setUint32(offset, ptr, true);\n                this.mem.setUint32(offset + 4, 0, true);\n                offset += 8;\n            });\n\n            // The linker guarantees global data starts from at least wasmMinDataAddr.\n            // Keep in sync with cmd/link/internal/ld/data.go:wasmMinDataAddr.\n            const wasmMinDataAddr = 4096 + 8192;\n            if (offset >= wasmMinDataAddr) {\n                throw new Error(\n                    'total length of command line and environment variables exceeds limit'\n                );\n            }\n\n            this._inst.exports.run(argc, argv);\n            if (this.exited) {\n                this._resolveExitPromise();\n            }\n            await this._exitPromise;\n        }\n\n        /**\n         *\n         */\n        _resume() {\n            if (this.exited) {\n                throw new Error('Go program has already exited');\n            }\n            this._inst.exports.resume();\n            if (this.exited) {\n                this._resolveExitPromise();\n            }\n        }\n\n        /**\n         *\n         * @param id\n         */\n        _makeFuncWrapper(id) {\n            const go = this;\n            return function () {\n                const event = { id: id, this: this, args: arguments };\n                go._pendingEvent = event;\n                go._resume();\n                return event.result;\n            };\n        }\n    };\n})();\n","module.exports = parcelRequire.resolve(\"main.aeb173d5.wasm\");"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$3d0c597f7f11ef48$var$wasm_ready_resolve","$7Dwz3","$3d0c597f7f11ef48$var$go","Go","$3d0c597f7f11ef48$var$wasmReady","Promise","resolve","response","fetch","a","__esModule","default","bytes","arrayBuffer","instance","WebAssembly","instantiate","importObject","run","self","onmessage","event","rpc","JSON","stringify","data","enosys","fs","outputBuf","constants","O_WRONLY","O_RDWR","O_CREAT","O_TRUNC","O_APPEND","O_EXCL","O_DIRECTORY","writeSync","fd","buf","nl","decoder","decode","lastIndexOf","console","log","substring","length","write","offset","position","callback","chmod","path","mode","chown","uid","gid","close","fchmod","fchown","fstat","fsync","ftruncate","lchown","link","lstat","mkdir","perm","open","flags","read","buffer","readdir","readlink","rename","from","to","rmdir","stat","symlink","truncate","unlink","utimes","atime","mtime","process","getuid","getgid","geteuid","getegid","getgroups","pid","ppid","umask","cwd","chdir","pathSegments","join","crypto","performance","TextEncoder","TextDecoder","encoder","argv","env","exit","warn","_exitPromise","_resolveExitPromise","_pendingEvent","_scheduledTimeouts","Map","_nextCallbackTimeoutID","setInt64","addr","v","mem","setUint32","Math","floor","getInt64","low","getUint32","high","getInt32","loadValue","f","getFloat64","isNaN","_values","storeValue","setFloat64","undefined","_ids","get","_idPool","pop","_goRefCounts","set","typeFlag","nanHead","loadSlice","array","len","Uint8Array","_inst","loadSliceOfValues","Array","i","loadString","saddr","DataView","testCallExport","b","testExport0","testExport","timeOrigin","Date","now","_gotest","add","callExport","gojs","sp","exited","p","n","msec","getTime","setInt32","setTimeout","_resume","has","clearTimeout","delete","getRandomValues","push","result","Reflect","getsp","deleteProperty","m","args","apply","setUint8","construct","parseInt","str","encode","String","dst","src","Uint8ClampedArray","toCopy","subarray","debug","value","Instance","NaN","fill","Infinity","strPtr","ptr","argc","argvPtrs","forEach","arg","keys","Object","sort","key","resume","_makeFuncWrapper","go","this","arguments","url","$parcel$distDir"],"version":3,"file":"worker.41b28b9f.js.map","sourceRoot":"../../client/web/"}